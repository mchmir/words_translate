In this tutorial, I am going to talk about list comprehensions. List comprehensions are actually one of my favorite features in Python. I know they can seem a little bit arcane at first or a little bit strange, but they are actually super helpful. They can help make your programs easier to read and easier to maintain, once you have actually wrapped your head around how they work.
And when you break them down to their first principles, they are relatively easy to understand. Behind the scenes, it's pretty much all just for loops, and that's what I am going to teach you in this tutorial.
I am going to show you exactly how you can take an existing for loop in Python and then transform it into a list comprehension, and also do the same thing the other way around. All right, so let's jump right in. So, here's a simple list comprehension that I just defined. You can see here, it looks kind of similar to defining a list constant, right, where we would just put in values between these square brackets.
So, I defined this list comprehension here, and then I assigned the result of it to the squares variable. The reason I did that is so you can see what the output of that list comprehension is, and I also wanted to give it a name because it's well, it's computing all the integer square numbers from 0 to 9.
And of course, I could have just taken the same list comprehension and run that immediately, right Now, when you look at this list comprehension, the syntax is fairly humanreadable, I want to say.
And really what this syntax is it's kind of a shorthand for a regular for loop. I am going to clear my screen here, and I am going to bring back the list comprehension.
Now, I am going to write a for loop that runs the exact same calculation. We're going to start out with an empty squares list, and we're going to populate that list as we go along. To start the for loop, I am going to take this part here from the list comprehension.
So, I am just copying and pasting it over.
And now what I need to do is I need to update squares, so I need to append something to it. For that, I am going to take this part of the calculation here. All right, so you can see where I copied these parts from.
The squares one so that one, and then the for loop is that one here, that part here in the list comprehension, and then the actual calculation that I am running here, or the expression that I am evaluating, I took that from here to calculate the squares.
All right, so when I take a look at how this squares list was populated by the for loop solution, you can see it's exactly the same.
So when I rerun the original list comprehension, you can see it has the exact same output. So, that's how you transform a very simple list comprehension into a for loop.
Now, if you try and generalize this structure so, the transformation that we just applied if you try and generalize that for any other kind of list comprehension, you might end up with a pattern somewhat like this.
So, what I have done here is I have taken the list comprehension up here that I used in the example, and I have replaced parts of it kind of, the parts that you would swap out that are not part of the skeleton for the list comprehension and I replaced them with these markers here. So in this case, the values which is our output values would correspond to what was called squares in the example, and then the expression would be the x * x operation that we're doing here.
And then, of course, this for part would be exactly the same. Then, we're taking a value in this case, it would be called x from a collection. In this case, it would be the range of integers from 0 to 9.
This is sort of the template behind this list comprehension. And as you have seen, we can take this template and transform it into another template. So, this list comprehension, if you wanted to transform it into a for loop, it would look like this.
This is pretty much exactly what we have done in the example. So again, our values here, that's just squares, and we're creating an empty list and then we're iterating over each value in the collection and you can see how these correspond here and then we're updating the output values that we previously initialized.
We're just appending stuff to that list, and we're not just taking the value from the collection and adding it, but we're evaluating some kind of expression based on that value to calculate the actual output value. So, this is how this transformation goes down, and the cool part is that it works in both directions, so you could apply the same transformation to actually take a for loop and turn it into a list comprehension again.
And that's kind of the powerful thing about these list comprehensions, because once you're getting tired of writing loops that look exactly like this well, now you have a tool in your toolbox that you can apply to make these parts in your program a little bit more readable, and basically turn these three lines into a oneliner that does exactly the same thing, which can be pretty powerful. It can be great for improving readability.
It can also be horrible for improving readability, but I am going to talk about that in a little bit, at the end. All right, so we just looked at this fairly simple pattern here, and what I want to talk about now is how you can expand this pattern to actually include filtering. And filtering is going to make the list comprehensions that you can write a lot more powerful and a lot more flexible, so let's take a look at that.
I have updated my example here by adding filtering, and you can see here that this looks very similar to the previous example. All of the parts that you're already familiar with are still there.
We have got our output list of values, we have got the expression we calculate, and we have got this for <value> in <collection> part that we run.
This new stuff here at the end, that's where the filtering happens. So in this case, we're calculating the same set of values, but we're only keeping the values where this condition here is True.
And in case you have seen the modulo operator before it divides two numbers and then gives you the remainder. So, if I go 31 % 2, the remainder of that is 1, because it's an odd number. We ca cleanly divide it by 2, so the remainder of that is 1. And if I go 30 % 2, then the remainder is 0.
I am taking advantage of that here in this filtering expression to only include values in this even_squares list that are actually even. So, this is a great way to find out if a number is even or odd.
You can just use the modulo operator for that. All right, so let's take a look at the output here that we have generated. As you can see, this filtered down the previous list of squares so that it only includes the even squares. So remember, this is what we had previously, before the filtering, and that also included odd numbers and now, those are all gone because we filtered them out with this if part in the list comprehension.
Now, let's take a look at how that affects our template behind the scenes or how can we transform this into a standard for loop template behind the scenes.
So, if you wanted to generate the same list with a for loop, you would probably do something like this. Again, you would start out by creating an empty output list, and then we would iterate over this range again.
And now what we need to add is the filtering. So in this case, I would just add the filtering condition here, inside the for loop,
and then if the filter condition is True, only then am I going to append the calculated value to my output list. This is exactly what I have done here, so hopefully, we'll get the same result. Yup that looks pretty good.
You can see here how I took the initial list comprehension with filtering and transformed it into an equivalent for loop. All right, so I have got the updated template here, and pretty much all that I have added is this if condition part.
We can take a look at how this would transform to a for loop. All right, and this is how it would transform into a for loop. So again, this is really similar to the previous template, but now we have added this if condition line that applies the filtering.
So you can see, if you build your understanding of list comprehensions stepbystep, then I think it becomes much easier to actually see what's going on. Because the jump from the previous list comprehension and then adding this if condition here is relatively small.
It's relatively easy to wrap your head around that. But if you have seen that for the first time, if you had seen a more complex list comprehension you know, like this one it would seem a little bit overwhelming, to be honest, because it just helps to break things down into these little steps, and hopefully that example showed you how these list comprehensions break down into these relatively simple for loops.
Now, there's a lot more to say about these list comprehensions or comprehensions in general, because there are also dictionary and set comprehensions, and I am going to put a link into the description of this video where you can learn about this stuff if you want to but before you run off and jump into refactoring your programs to add list comprehensions to them, I want to talk a little bit about two things.
So, number one is formatting: How should you format your list comprehension so they look nice and clean Because one downside here is that they can get super long and can kind of go past the line length limit that you might have set for yourself, or if you're using pep8, you know, it's really easy to go over that limit.
So, I want to talk a little bit about that, how I like to format my list comprehensions. And then also I want to give a bit of a caveat here, where list comprehensions seem like a really great tool and they are but there's also a danger of overusing them, so I want to give just my opinion on that, and when it makes sense to use or not use a list comprehension. All right, so in terms of formatting, what I like to do is if I have a slightly more complex list comprehension and it does fit into one line, often what I'll do is I'll align my comprehension that way so that I have got the expression on the first line, and then I'll put the for part below that and I'll put the filter part on another line. I feel like that reads pretty well and looks pretty clean, and it's a good way to format your list comprehensions if they run the danger of spilling across the line boundary, right So, that's a way you could do this.
To show you an example of what this would look like with the even_squares example that we had previously, I might do something like this or actually in this case, because I have enough space, I would probably do something like this, and actually leave the filtering down there, or even put it on a single line because that's only 56 or 55 characters here, so this is not going to hurt too much.
But I hope this gives you an idea of what you can do if you have, for example, if you have a longer function call here then it might make sense to format this differently and actually move this down or do something like this.
Like basically, what I wanted to say here is that I like using these parts here in the template as my breakpoints if I need them. That can help you break it down if you're getting close to the line boundary. All right.
So, the other thing I wanted to talk about is that you want to be careful with how often and under what circumstances you use these list comprehensions.
So, one downside of list comprehensions is that, well, they are more terse than for loops. They can feel or they can get a little bit overwhelming if someone is not familiar with them.
So with this feature, I think it makes sense to balance it with, for example, who you're working with. If you want to introduce Python to a new team, maybe blasting them with a bunch of list comprehensions is the greatest way to do that.
Because a for loop is probably going to seem more familiar to them than hitting them with a list comprehension right away. So depending on the developer audience you're working with, these list comprehensions might be a good feature to use, or they might not be.
This is something to keep in mind. The other thing is that these list comprehensions can also be nested. You can have list comprehensions inside list comprehensions.
And this is something that I would encourage to stay away from that. It's much better to turn that into a loop or actually even move part of it into a separate function call, because it's going to be a lot easier to read and a lot easier to maintain. So, you can write some pretty gnarly list comprehensions, and usually you know, it's tempting, I know it's tempting but usually it's not a great idea to do that, because it gets super confusing really quickly and it gets extremely hard to maintain.
So it makes sense to really spend some time to think about it, whether it's better to use a list comprehension in a specific use case or not. So, that was a word of warning here at the end, but I think it's definitely something you want to keep in mind.
Like, all code is communication and you always want to make sure you're communicating your intent clearly, and that you're not writing code just for the sake of making it extremely terse or concise or overly concise, right Because I know it's fun, I have done it in the past and I have done it to other people and really, it just kind of sucks, so I would recommend that you do do that.
I mean, definitely use list comprehensions they are awesome. I think for something like that, in my mind, that's much cleaner than using the equivalent for loop, but be careful with deep nesting and some of the crazier list comprehensions you might want to write.
Today, I want to talk about how you can control how a Python class is represented as a string, and also when you interact with it or inspect it in a Python interpreter session. So, let's start with a really simple example here.
I have got my popular Car class, and we're just going to create a simple Car object here. And what you can see is that when I print this Car object, we kind of get this unsatisfying result, and it's the same when I just inspect the object in this interpreter session. So you can see here, well, at least it gives us the class name kind of the whole namespace of this thing but it only gives us the memory address, you know, if we're on CPython, it just gives us this ID. And it's kind of opaque and kind of hard to understand what's going on. So, this is better than nothing, but it's not super useful.
Now, there's a common workaround that I see some people apply. For example, they start printing out the class attributes directly. And sure that works, you can do that.
We can kind of pry that class apart and reach in and take out the .color and the .mileage here that works. And then what I see some people do is they would kind of go ahead and do their own to_string method, right
And then that would print directly or return a string representing the class. But there is a convention inside Python that handles all of that, so you do have to come up with your own ways to do that because there's actually preexisting conventions on how to do that.
So, I want to explain to you how that works. Basically what you're going to learn today is how the and . methods work in Python. This is going to be a highly useful thing.
This is a common interview question. So, you know, watching this tutorial could literally pay you money in the future, so stay tuned if you do know how this stuff works.
Okay. So, to ease into this with a simple example, I took the same Car class and I added a method here. So, the dunder methods are methods that start with a double underscore it's just kind of been shortened to dunder.
Some people refer to them as magic methods a lot of people do like that because they're not really supposed to be magical in any way. They're just supposed to be, well, a Python convention. And the dunder, or the double underscore , marks them as a core Python thing, so classes are not supposed to actually define their own dunder methods because it could conflict with Python features in the future.
And so this is just a way to kind of namespace these things a little bit, just by a naming convention, kind of keeping them separate a little bit, just like the .init method.
But you know total sidetrack here. So what I have done here is I added a method. And basically what I did here whenever that method is called, it just returns the .color of the Car and kind of tells us it's a Car.
So just to show you an example here again, I am going to create the same Car. And now when I print this Car
I actually get a completely different result, right So this time I get a red car which is the result of this method instead of this crazy string with the object address in memory. However, when I just inspect this object, I still get the memory address in the previous result.
So, inspecting the Car object still gives the same result, but when I printed the Car object, I got this different result based on the method.
The way you would actually convert an object to string if you wanted to force that or make that happen you would just use the builtin str method, and then that is internally going to do the right thing and call the method, and it's going to give you back the right result.
Now, all of these functions that deal with text representations for objects, like the print function they are going to do that internally.
They're going to call the str function for you. And it would be the same with a format string, for example. So if you do this, then this would also call and just give you the result.
But the key thing is here that by convention, if you add a method, then it's going to do a lot of good for you in controlling how your object is represented as a string. So it's the Pythonic way to do this, which is kind of the Holy Grail, right Now, still what you're seeing here was that when I inspected the my_car object in the console, I still got the same result.
So there seems to be different ways to convert your objects into strings. The first one we just learned about it's called dunder str.
And now the second one is called dunder repr. Let's talk about what . does and how it's different to .
In order to understand what's going on here, I defined this class or, kind of, redefined my Car class. And what this new version of the Car class does, it actually has a . and a implementation.
Now, those implementations are just dummy implementations that are going to tell us what's going on behind the scenes. So, if something calls . behind the scenes, we're going to get 'repr for Car' as a result, and if something calls , we're going to get 'str for Car' as a result.
So now, we can walk through to the same example again and do a printmy_car. And you can see here, okay, it called the function.
We could also go through the .format example again you can see it called the function. And now, if we do my_car and just inspect that, we can see here that it's actually called . for the Car.
And another way to force this is to call the builtin repr function,
and then that's going to do the right thing and call the correct . implementation for this. Usually, you just want to use the str and repr helpers for that.
Now, of course, the big question is, Okay, so now we have these two what's actually the difference between them, or what's the different use cases where you would use them
All right, so we have and we have and they're both called by some convention but, you know what's actually the difference
Like, should they return the same thing How are we going to deal with this And the answer that I have got for you is let's look at what some of the Python builtin classes from the Python standard library are doing here.
So, what I am going to do here is I am going to import the datetime module, and then we're just going to create a new date object. All right, so I just created a new datetime.date object.
And then we're going to try and experiment with that so we can see how it reacts, right How does its and . function react, and what result do we get from it
So, let's call str on that date object.
And you can see here, we get a pretty concise representation it's quite readable. It looks like an ISO date format, which is kind of the standard representation for a date in string form.
Okay, ha. And now we call repr on the same object instance.
It actually looks quite different, because now we get a more elaborate result that is really unambiguous, right This is not any kind of date, but we know exactly it's a datetime.date object and it was created in this way.
And we could even copy and paste this and execute that as valid Python, and it would recreate the same object, right Like I said earlier, when you call, when you just inspect an object in the interpreter, that also gives you the ..
This gives us a pretty good idea of the difference between and 
When you actually go to the Python documentation and do some reading on the best practices that people have come up with in the community, then you'll learn that the method it's mainly used for giving an easytoread representation of your class. All right, so should be easy to read and it's meant for human consumption.
So, you can see that here it's this ISO date. You could display that to a user and it would be too bad. With on the other hand, it should be unambiguous.
The goal here really is to be as explicit as possible about what this object is. And it's, I guess, more meant for internal use and something that would make things easier to debug for a developer, but you would necessarily want to display that to a user.
And so some people actually recommend that the result of your . should be something like this, that would actually be valid Python and that you could just run again and would recreate the same object. Now, personally, I find that this is a really good idea, but it's usually really hard to attain that in practice.
So, the bottom line is that you want your . to be unambiguous and more meant for developers, but the you want that to be easy to read and potentially for human consumption.
So now, there are a couple of more interesting things that I want to talk about here because they really make this whole thing a little bit easier to understand how it works in the real world. So, the next example I want to show you is an actual implementation that someone might take for their class. And because Python falls back to calling . if you do define a separate implementation, my recommendation is actually to put a . on any class that you define, because then you get a pretty helpful and readable result in all cases, and now what I am going to do is also give you a complete example of how you would do that, because there's a slight trick you can apply to make this a little bit easier to work with. So again, I have got my Car class here, and I am defining the . right now, and so how I would go about doing this is, well, returning a string that contains the Car class name, and then I would probably do this self.color,
and self.mileage, right That's a format string, and then I would just pass the self object. Now, a common thing that I see here is that usually, you have to retype the name of the class inside the but there's actually a way to get around that because we can just reach into the class itself and ask it for its name.
So, what you can do here instead is you can use self.class.name. This is getting kind of long, so you want to make sure you format that in a way that's sensible.
But basically, what this is going to do is it's going to automatically use the right name for the class, so you do have to make sure you update this, right
So, you might not want that in some cases maybe you want the . class name to be static but usually, this is a good default implementation for your ..
And now, when I create a new my_car object and I inspect it, I get a really nice result.
And also, when I call str on it or when I print the Car, I get the same result, because the default implementation for str just calls . internally. Okay, so this is kind of the minimum implementation I would recommend to you, where you're adding a . to any class that you define.
You kind of leave the on the side and you would use something like this so you do have to type the class name again.
Okay, so before we wrap this up, there's one more thing I wanted to mention, and that is how containers convert their child objects the objects they contain to string.
Maybe the surprising thing is that even if you call str on a container so, I am creating this list object here even if you call str on a container, it's going to represent the internal objects with the . function.
So when I you know, I am using the today object, which is just a datetime object or, datetime.date object. So, when I have this list here of these three date objects and then I call str on it, I actually get a string back that has the container with the . inside.
So, this is just something to keep in mind how that works. If you wanted to convert those with the str function individually, you would just need a loop or some kind of list comprehension to do that manually. But you know, that's just a side note.
I think, really, the bottom line or the one takeaway from this thing here is # At least add a repr to your classes :.
All right So, I hope you learned something new today and you're going to be able to apply that in a realworld program or in some code that you write. Cool
Well, happy Pythoning, and I'll talk to you soon.
Hey there It's Dan. Today I want to talk about the difference between class methods, static methods, and plain, or regular, instance methods in Python. Kind of demystify some of differences between them, when you would use each, what are some of the common scenarios, and how you can use them to actually make your code cleaner and more maintainable and easier to work with in the future.
Okay, so let's jump right in. I want to make this really handson and work from a simple example that I can use to show you the difference. So, I created this class, I call it MyClass. It's just a really simple example, and it's got a couple of different method types on it.
So, the first one is just called method, or the method is called method, and it's just a plain instance method. And you can see here, it takes one argument, the self argument, which points to the object instance.
That means within .method, we can actually modify or read attributes on the object instance. And when you compare that to a class method so, I just called this one classmethod and then use the @classmethod decorator to actually mark it as a class method you can see here that the .classmethod only has access to this cls class parameter,
or cls argument. It does have have a self argument. So, this means a class method can only access the class itself, or the object representing the class, because well, everything is an object in Python. But the key difference is that when I create an instance of MyClass and call .classmethod on it, it wo be able to actually access the self object, right So, it can only access attributes that actually exists on the class itself, and not on the instance. Now, with a static method, again, the approach is really similar.
You just define a regular method and then mark it with the @staticmethod decorator. What you can see here is that it does take any arguments at all, so it has no access to the class or the object instance at all.
It's completely separate from that, and it's really just a way to namespace your methods. So now, you know, I know this is very theoretical at this point, and it's going to become much more clear when we actually try and do some experimentation with this stuff some handson work.
So, the first thing I want to show you here is that when I create an object instance based on this class, I can actually call any of these method types on that object.
So, I can call a plain method and I kind of structured these methods in a way that they return a string that kind of explains what's going on. All right, so when I call obj.method, we can see here that, well, we called the instance method and we had this self object pointing to an instance of MyClass.
Now, I can do the same thing with a class method, and now when I call this, you can see here that, again, we're calling this .classmethod method, and this time we also have access to this class object.
Now, the difference is that with the instance method, we actually had access to the object instance, right So, this was an instance of a MyClass object.
Whereas with the class method, we have access to the class itself, but not to any of the objects because the class method does really care about an object existing. However, you can both call .classmethod and .staticmethod on an object instance.
This is going to work it does really make a difference. So again, when you call .staticmethod here, it's going to work and it's going to know which method you want to call, but really, the key difference now is going to be that we can also say, okay, MyClass and I am not creating an instance of this class and I can go in and say .classmethod, for example.
This is going to work fine. And I can also go ahead and call the .staticmethod. This is also going to work fine. But of course, when I try and call .method, that's going to fail because we did actually call it with a class instance.
So, I hope this makes this distinction between regular methods and static and class methods a little bit more clear. Now, of course, the big question is, Okay, why…why do we need that Why… why is that a thing And I want to go over some examples here of what you can use these methods for,
because I think they're actually a really powerful concept, or a really powerful tool, for you to structure your code in a way that makes the most sense.
Okay. So, this is what I came up with: the classical pizza example for teaching objectoriented programming. So what I have done here is I defined this really simple Pizza class.
It's got a constructor that takes some arbitrary ingredients object we're just going to assume it's some kind of list or container with these ingredients and then also put a . on it so we can nicely format it as a string. And in here, if you're wondering what that is so, that is the new format strings in Python 3.6, which are really awesome, so I highly encourage you to try that out.
You could also just use regular format strings, of course. So, okay. Basically, what I did here, is I created this Pizza class and now we can use it to create Pizza objects, right And so, if I am not mistaken, that's a Margherita
Um…my wife's Italian you would probably kick my ass if I got that wrong but I think that's a Margherita. Well, what you have seen here is that we can create these Pizza objects, but as we create more and more complicated pizzas ham, like a prosciutto or something, I do know. Maybe we need some mushrooms on that, as well.
And you can already tell I am struggling with the naming here, right I can create all of these wonderful pizzas here, but I need to remember all of these ingredients.
So now, it would be too much of a stretch to actually solve this problem with a static method. Okay. So, I wanted to make it a little bit easier for us to create new Pizza objects without having to remember all of these ingredients.
A really good way to structure this, in my opinion, is to actually use class methods to have different factory functions for the different types of pizza you can create. I am going to show you how this works in a minute now.
So, what I am going to do here is I am going to define a margherita class method here,
and then that's just going to create a new instance of the class…
and let me just type that out here. What I am doing here is whenever this .margherita method is called and we can call it on just a Pizza class, we do actually need a real Pizza instance I am just going to create an instance of a Pizza or, you know, whatever the class is named. Like, the nice thing here is that I do have to refer to the name up here, so I can keep that name just in one place and whenever I update it I do have to worry about changing the rest of the code, but it's just going to use the class object's it's just going to call this .init method, here, and it's going to create a new Pizza with these ingredients.
And so, this is a really maintainable way to do these factory functions. I could also have a .prosciutto I did actually look the spelling up for this, all right
So, if any Italians are watching this
then let me know if I screwed this up
So here, we actually want a cheese I guess it would be amozzarella right, and not 'cheese but whatever it's a kind of cheese. Anyway, this is about cheese this is about Python. So, okay.
I am creating a different kind of pizza here, and now when I finish defining this class, I can actually say, Hey,
I want a Margherita,
and that returns a new Pizza object, right I could have also called this make_margherita or new_margherita, or something like that, right
Just to kind of have a better naming scheme. But the same thing is going to work with the .prosciutto. And I feel like this is a really good use for these class methods.
If you have classes with complicated constructors that take a lot of arguments and you want to provide a simplified interface for your users, then I think using a class method in this fashion can be really beneficial, and it's just going to make the API a little bit easier for people to work with.
So, this is one example of where I would use a static method. I mean, of course, you could always argue that maybe this should be a separate function, yada yada yada, but I think in some cases this could really work well if you structure your classes that way. Up next, when to use static methods. So it's a little bit hard to come up with a really simple example here, but you know, I am going to keep stretching the pizza thing here. So, okay. This is what I came up with.
Basically, a static method does have access to the class or the object instance at all, right And now, that's a pretty big limitation, but it's also a really good signal to show that a particular method is really independent from everything else around it, right So for example, if I flag this as a static method, it's pretty clear that this method, it's probably not going to change the object or the class in any way, because it's not really meant to have access to it. I mean, sure, you know, you could probably work around that and it could kind of work with a global variable, but in general, it's a pretty good hint that this is a selfcontained method, which has all kinds of benefits for later testing this thing and just kind of understanding the limitations of this method.
And so in some cases, it can really be helpful to make your code easier to maintain in the future, because you're really communicating this intent where someone else reading this code can pretty clearly understand that in this case, our little ._circle_area function here it's not going to modify the state of this object itself. So, let me walk you through this example real quick.
o basically, what I have added here well, I kind of changed the constructor around a bit, so now we have got a radius argument here for the pizza as well.
I forgot to update the but you know, it does really matter for now. And then I added this .area function. And, well, I could have just calculated the area of the pizza directly in here, but I wanted to have a static method in there.
And so basically, what I did there instead of calculating the area directly with an expression here, I am just offloading that to the ._circle_area function, and then the ._circle_area function just takes an r, which is the radius, and uses the classic r ^ 2 * pi formula to calculate the circle area.
So, you know, this is honestly kind of a simplistic example, and you usually would implement it like that, but it goes to show the concept. And now what happens here is I can instantiate a Pizza.
So for example, this is a really sad pizza with like 4.5 well, we do have a unit on that let's say meters. A giant pizza, cheese only. And we're going to create this object, this Pizza object, and then we're going to call the .area function on it, and it's going to give us this result.
So, the way this is calculated is that .area actually forks off all that work to the ._circle_area function, and now the ._circle_area function is actually completely independent, and I also used a single underscore _ to mark it as not part of the public API of this class, but kind of an internal implementation detail. But nevertheless, now the cool thing is that we have this ._circle_area function that is completely independent from the rest of the object, and it ca actually modify the object's state.
This is a pretty good hint for someone else reading the code and it also simplifies testing because when I write my tests for this, then I do have to worry about instantiating a Pizza object, making sure it does get modified, because the ._circle_area helper it ca do that. Right And so I occasionally use static methods to communicate that intent and to keep my helper functions nice and clean and make sure that they're not modifying the object's state all over the place. Again, just a quick recap. So we talked about plain methods, class methods, and static methods, and when you can call them. Pretty much all you need to remember is that a regular method needs an object instance to be called on; and in a class method, it needs a class and it has access to the class; and a static method does really have any access to the object, or an object instance, or the class at all,
and it's just kind of a way to namespace your functions. All right, so have fun exploring the pizza analogy here and building the perfect pizza API in an objectoriented fashion. Talk to you soon, and happy Pythoning